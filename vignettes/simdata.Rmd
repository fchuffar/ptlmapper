---
title: "A General Method to map Single-cell Probabilistic Trait Loci of the Genome (Simulated Dataset)"
author: "Florent Chuffart, Magali Richard"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{A General Method to map Single-cell Probabilistic Trait Loci of the Genome (Simulated Dataset)}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---



## Introduction

### Dataset

This report presents the analysis of a simulated dataset. 

The dataset is obtain from a simulator. The implemented model describes the behaviour of an auto-regulated single gene.
The production of protein is control by the following equation:
\[P = \frac{\alpha_0 + \alpha_1 (\frac{P}{K})^h}{1+(\frac{P}{K})^h}\]

We use two sets of parameter to produce cell populations:

\[\left\lbrace
  \begin{array}{l}
    \alpha_0 = 0.1 \\
    \alpha_1 = 10 \\
    K = 1.6
  \end{array}
\right.\]

\[\left\lbrace
  \begin{array}{l}
    \alpha_0 = 6.3\\
    \alpha_1 = 12\\
    K = 10
  \end{array}
\right.\]

For each individual we generate 20000 cells according to one of this two set of parameters and a given level of error on the parameter values.

The dataset is freely available as an R package called `ptldata` (https://github.com/fchuffar/ptldata).


The R package called `ptldata` exposes following objects:

```{r}
library(ptldata)
indiv = ptldata::indiv
genodata = ptldata::genodata
cells = ptldata::cells
```

#### indiv

`indiv` describes the simulated individuals. It is a data frame that contains the description of the 1490
 individuals. It is compose dof  1490 rows and 8 variables:

  * `err`, the value of the error introducted in the paramater selection level.
  * `all`, the discriminant parental allele orign.
  * `a0`, the a0 parameter value.
  * `a1`, rhe a1 parameter value.
  * `k`, the k parameter value.
  * `m1`, the first moment of the single cell distribution.
  * `m2`, the second moment of the single cell distribution.
  * `m3`, the third moment of the single cell distribution.

The `indiv` rows are named with corresponding individual names.

```{r}
head(indiv)
```

In this study, we only focus on individuals that have been generated with the level of error of 0.2 and, for computanial reason we down sample 80 individuals.


```{r}
err = 0.2
nb_indiv = 80
idx = which(indiv$err==err)[1:nb_indiv]
cells = cells[idx]
indiv = indiv[idx,]
genodata = genodata[,idx]
```

This picture shows the distribution of the first, second and third moment of the single cells data associated to each individual in grey and its composition (in blue and red) if we considere discriminant parental allele orign. Red and blue histograms of the first and second moment are overlaping. The two same histograms of the third moemnt are separated.

```{r,fig.height=3, fig.width=9}
layout(matrix(1:3, 1), respect=TRUE)
for (m in c("m1","m2","m3")){  
  h = hist(indiv[[m]], nclass=20, 
    main=paste("moment", m, sep=""), xlab="", ylab="", 
    col=adjustcolor("grey", alpha=0.3))
  for (all in unique(indiv$all)) {
    h = hist(indiv[indiv$all==all,][[m]], plot=FALSE, breaks=h$breaks)    
    lines(h, col=adjustcolor(all+1, alpha=0.3))
  }
}
```

#### genodata

`genodata` specify the genotype of the simulated individuals. It is 
a data frame with 210 rows and 1490 columns whose rows are markers and columns are individuals. The
marker 101 corresponds to the 'all' variable of the 'indiv' data
frame, it is the parental allele linked with the phenotype. From
this marker 101, genotype is propagated (upstream and downstream)
with recombination factor of 5


The `genodata` columns are named with corresponding individual names.
The `genodata` rows are named by marker name.

```{r}
genodata[1:10, 1:7]
```

The following image figures out the parental origin of segregant genomes according to marker.

```{r,fig.height=6, fig.width=6}
tetas = compute_teta(genodata)
matlab::imagesc(t(as.matrix(genodata)), 
  main="Parental origin of segregant genomes", 
  xlab="markers", ylab="segrgants")
```

The following plot represents the distribution of the recombination factor (teta) between marker.

```{r,fig.height=6, fig.width=6}
plot(density(tetas), 
  main=paste("Recombination Fraction Distribution"), 
  xlab=paste("mean(teta)=", signif(mean(tetas),3), sep=""))
abline(v=mean(tetas), lty=2)
```

#### cells

`cells` emdeb simulated single cell values (phenotypes) of individuals. 
It is a list of the 20000 single cell values (phenotype) of the 1490
individuals described by the variable 'indiv'. It is composed of 1490 items,
each item is a vector of 20000 integer

The `cells` list is named with corresponding individual names.

```{r}
head(names(cells))
```


```{r,fig.width=6, fig.height=6}
# plot_dist(ptl_mapping_result, main=main, col=col)
library(ptlmapper)
```

### Method

The main purpose of this analysis is to presents a general method allowing to map Probabilistic Trait Loci (PTL).
This analysis is composed of the following steps:

#### analysis of the single cell signal (phenotype)

From the list of single-cell values we build histograms. 
We obtain a list of histogram, one per individual. 
All this histograms have the same `breaks` values. 

```{r}
pheno_hists = build_pheno_hists(cells, bin_width=1)
```

#### computation of the Kantorovitch distance matrix

From the list of histograms we build the Kantorovitch distance matrix. 
Since Kantorovitch distance between two individuals is computed using their histograms, 
it is important that the `breaks` values.
This matrix is a symetric distance matrix where columns and rows are named by name of the corresponding individual.

```{r}
kd_matrix = build_kd_matrix(pheno_hists)
head(kd_matrix)
```

#### computation of the multivariate moments matrix

From the list of single values stored in the histograms we build the multivariate moments matrix. 
This matrix is composed of 1 line per individual named by the name of the individual and `nb_moment` columns named from `moment_1`.

```{r}
mm_matrix = build_mmoments_matrix(pheno_hists, nb_moment=4)
head(mm_matrix)
```

#### preparation of the genotype

The methods needs an annotated genome to work fine. Here, we four colums to our genodata data frame: 

  * `prob_name`, the probe name associated to the marker.
  * `chromosome`, the chromosome on which the marker is.
  * `position`, the position of the marker in the chromosome.
  * `rec_fractions`, the recombination factor associated to the marker.

In `genodata`, "2" stands for undetermined and is replaced by NA.

```{r}
bckg = names(cells)
genodata$chromosome = 1
genodata$position = 1:nrow(genodata)
genodata$prob_name = rownames(genodata)
genodata$rec_fractions = 0.05
genodata_ptl = preprocess_genodata(genodata, bckg)
```


#### do the ptl mapping using Kantovitch and multivariate moments method

The `plt_mapping` function scans genomes to detect PTLs using one of the two methods: `kanto` or `mmoments`. Refers to the publication for more details.
The common algorithm is the following. Phenotypes of individuals are described by vector (PCA on mm_matrix or MDS on kd_matrix). The algorithm determines with the Kaiser criterion how which dimensions of this orthogonal transformation are relevants for canonical analysis (`eig_to_scan`).
If `nb_dim=0`, a z-core criterion id used to determine with how many dimensions the canonical analysis gives the best result. The main purpose is to fixe `nb_dim` in `2:max(eig_to_scan)`.
If `nb_dim=NULL`, `nb_dim` is automatically set to `max(eig_to_scan)`.
If `nb_dim>0` the canonical analysis is performed using the provided `nb_dim`. In this two last cases, pay attention that a high value of `nb_dim` introduces a lot of degree of freedom in your canonical analysis. The number of dimension `nb_dim` needs to be __substantially__ smaller than the size of your population. 

```{r}
kanto_analysis = ptl_scan(kd_matrix, genodata_ptl, nb_perm=3, method="kanto")
mmoments_analysis = ptl_scan(mm_matrix, genodata_ptl, nb_perm=3, method="mmoments")
```


#### do the qtl mapping using the classic method

The `ptlmapper` package embed features of the famous `qtl` package [Broman et al. (2003)]. It allows to perform classic QTL mapping on univariate criteria (ex: mean, variance) using `ptlmapper` data structires. 

```{r}
rqtl_analysis = rqtl_launch(genodata_ptl, pheno_hists, kanto_analysis, mmoments_analysis)
```


### Workflow


All this steps embeded in the `ptl_mapping` function. 
This function is a workflow that aggregates parameter values, inputs and outputs of the call to the R package `ptlmapper` function. 
The resulting data structure could be cache on the file system (using `ptl_mapping_filename` argument of the function). 
It is useful to massivelly save multiple call to `plt_scan` and `rqtl_launch` function, for example in a complex distributed design.  

```{r}
ptl_mapping_result = ptl_mapping(genodata_ptl, cells, bckg, nb_perm=3, bin_width=1)
```


### Result

#### QTL
```{r,fig.height=3, fig.width=9}
layout(matrix(1:3, 1, byrow=TRUE), respect=TRUE)
plot_rqtl(ptl_mapping_result, which_pheno=1)
plot_rqtl(ptl_mapping_result, which_pheno=2)
plot_rqtl(ptl_mapping_result, which_pheno=3)
```

#### PTL

##### Kantovitch method
```{r,fig.height=3, fig.width=9}
layout(matrix(1:3, 1, byrow=TRUE), respect=TRUE)
plot_mds(ptl_mapping_result, main=main, col=col)
plot_wilks(ptl_mapping_result, main=main, method="kanto")
plot_can(ptl_mapping_result, marker_names[1], main=main, col=col)
```


##### multivariate moments method
```{r,fig.height=3, fig.width=9}
layout(matrix(1:3, 1, byrow=TRUE), respect=TRUE)
plot_wilks(ptl_mapping_result=ptl_mapping_result, pa=ptl_mapping_result$mmoments_analysis, main=paste(nb_indiv, "indiv (mm)"), method="mmoments")
plot_dist(ptl_mapping_result, main=main, col=col)
```


## Bibliography

  * Broman et al. (2003) R/qtl: QTL mapping in experimental crosses. Bioinformatics 19:889-890



## Acknowlegment

We are grateful to the Pole Scientifique de Modelisation Numerique (Lyon, France) and the Grid'5000 experimental testbed (www.grid5000.fr) for computer resource, and the Centre Blaise Pascal of ENS de Lyon for housing the code on a forge. This work was supported by the European Research Council under the European Union's Seventh Framework Programme FP7/2007-2013 [grant SiGHT number 281359].
