---
title: "A General Method to map Single-cell Probabilistic Trait Loci of the Genome (Simulated Dataset)"
author: "Florent Chuffart, Magali Richard"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{A General Method to map Single-cell Probabilistic Trait Loci of the Genome (Simulated Dataset)}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---



## Introduction

### Dataset

This report presents the analysis of a simulated dataset. 

The dataset is obtained from a simulator. The implemented model describes the expression of a single gene with positive autoregulation.
The protein production is controled by the following equation:
\[P = \frac{\alpha_0 + \alpha_1 (\frac{P}{K})^h}{1+(\frac{P}{K})^h}\]

We considere two different genetypic groups, that are characterized by the following sets of parameters:

<span style="color:red;">
\[\left\lbrace
  \begin{array}{l}
    \alpha_0 = 0.1 \\
    \alpha_1 = 10 \\
    K = 1.6
  \end{array}
\right.\]
</span> 

<span style="color:blue;">
\[\left\lbrace
  \begin{array}{l}
    \alpha_0 = 6.3\\
    \alpha_1 = 12\\
    K = 10
  \end{array}
\right.\]
</span> 

We assume that the set of parameters is controlled by one locus that could exist in two different allelic forms (A and B).

For each individual, we generate 20,000 cells according a given set of parameter values. 
In addition, we added a universal noise term $n$ to introduce intra-genotype inter-individual varation.
This correspond to variations of the level of errors on the parameter values.

We considere a panel of individuals and their genotype at 200 markers evenly spaced every 5cM. 

For simplicity, individuals are considered as haploid segregants derived from a cross between two haploids parents of genotype A and B, respectively. 

The dataset is freely available as an R package called `ptldata` (https://github.com/fchuffar/ptldata).

The R package called `ptldata` provides following objects:

```{r}
library(ptldata)
indiv = ptldata::indiv
genodata = ptldata::genodata
cells = ptldata::cells
```

#### indiv

`indiv` displays the relevant informations on all the simulated individuals. It is a dataframe that contains the description of the 1490
 individuals. It is composed of 1490 rows and 8 variables:

  * `err`, the value of the error introducted in the paramater selection level.
  * `all`, the discriminant parental allele origin.
  * `a0`, the a0 parameter value.
  * `a1`, rhe a1 parameter value.
  * `k`, the k parameter value.
  * `m1`, the first moment of the single cell distribution.
  * `m2`, the second moment of the single cell distribution.
  * `m3`, the third moment of the single cell distribution.

The `indiv` rows are named with corresponding individual names.

In this study, we only focus on individuals that have been generated with a level of error of 0.2 and, for computanial reason we down sample 80 individuals.


```{r}
err = 0.2
nb_indiv = 80
idx = which(indiv$err==err)[1:nb_indiv]
cells = cells[idx]
indiv = indiv[idx,]
genodata = genodata[,idx]
head(indiv)
```

This picture shows the distribution of the first, second and third moment of the single cells data associated to each individual (grey bars).
We also color the histograms according to the individual genotype at the locus of interest (allele A in red and allele B in blue). 
This corresponds to the discriminant parental allele origin, displayed in the the 'all' variable of the 'indiv' dataframe. 
The 'all' variable is equal to 1 for allele A, to 2 for allele B and to 3 when the genotype is undetermined. 

We observe that the distributions of the third moment are separated according to individual genotypes.


```{r,fig.height=3, fig.width=9}
layout(matrix(1:3, 1), respect=TRUE)
for (m in c("m1","m2","m3")){  
  h = hist(indiv[[m]], nclass=20, main=m, xlab="", ylab="", col="grey")
  for (all in unique(indiv$all)) {
    h = hist(indiv[indiv$all==all,][[m]], plot=FALSE, breaks=h$breaks)    
    lines(h, col=adjustcolor(all*2, alpha=0.3))
  }
}
```

#### genodata

`genodata` specifies the genotype of the simulated individuals at the 201 markers that we considere. It is 
a data frame with 201 rows and 1490 columns whose rows are markers and columns are individuals. The
marker 101 correspond to the locus controlling the gene expression that we use as phenotypic output.
The marker 101 is represented by to the 'all' variable of the 'indiv' data
frame. From this marker 101, the parental genotype is propagated (upstream and downstream) at each marker
with a recombination factor of 5 (corresponding to 5cM).

The `genodata` columns are named with corresponding individual names.
The `genodata` rows are named by marker name.

```{r}
genodata[96:106, 1:7]
```

The following figure represents the parental origin of each marker (i.e the genotype at each marker) for each segregant.

```{r,fig.height=6, fig.width=6}
tetas = compute_teta(genodata)
matlab::imagesc(t(as.matrix(genodata)), 
  main="Parental origin of segregant genomes", 
  xlab="markers", ylab="segrgants")
```


The following plot represents the distribution of the recombination factor (teta) between each marker. 
As expected, it is center on 0.05, which corresponds to a distance of 5cM between each marker.

```{r,fig.height=6, fig.width=6}
plot(density(tetas), 
  main=paste("Recombination Fraction Distribution"), 
  xlab=paste("mean(teta)=", signif(mean(tetas),3), sep=""))
abline(v=mean(tetas), lty=2)
```

#### cells

`cells` emdebs simulated single cell values (phenotypes) obtained for each individuals. 
It is a list of the 20000 single cell values (phenotype) of the 1490
individuals described by the variable 'indiv'. It is composed of 1490 items,
each item is a vector of 20000 integers.

The `cells` list is named with corresponding individual names.

```{r}
head(names(cells))
```
This plot figures out the distribution of single cell values for each individual colored according the discriminant parental allele origin.

```{r,fig.width=6, fig.height=6}
plot(0,0, col=0, xlim=c(-1.5,27), ylim=c(0,0.3), 
  main="distribution of phenotypes", xlab="single cell value", ylab="density")
foo = sapply(rownames(indiv), function(i) {
  lines(density(cells[[i]], bw=1), col=indiv[i,"all"]*2)
})
```

### Method

The main purpose of this analysis is to present a general method allowing to map Probabilistic Trait Loci (PTL).
Functions presented here are freely availables in the R package `ptlmapper`.

```{r}
library(ptlmapper)
```

This analysis is composed of the following steps:

#### Analysis of the single cell signal (phenotype)

For each individual, we construct one histogram that is based on the list of single-cell values.
We obtain a list of histograms (one per individual), that all share the same `breaks` values. 

```{r}
pheno_hists = build_pheno_hists(cells, bin_width=1)
```

#### Computation of the Kantorovitch distance matrix

From the list of histograms, we build the Kantorovitch distance matrix. 
Since Kantorovitch distance between two individuals is computed using their histograms, it is important that the `breaks` values remains identical between individuals.
This matrix is a symetric distance matrix where columns and rows are named after the corresponding individual.

```{r}
kd_matrix = build_kd_matrix(pheno_hists)
kd_matrix[1:6,1:6]
```

#### Computation of the multivariate moments matrix

From the list of single cell values stored in the histograms we build the multivariate moments matrix. 
This matrix is composed of 1 line per individual (named after the individual) and `nb_moment` columns named from `moment_1` to `moment_nb`.

```{r}
mm_matrix = build_mmoments_matrix(pheno_hists, nb_moment=4)
head(mm_matrix)
```

#### Preparation of the genotype

The methods needs an annotated genome to work fine. Here, we add four colums to our genodata data frame: 

  * `prob_name`, the probe name associated to the marker.
  * `chromosome`, the chromosome on which the marker is.
  * `position`, the position of the marker in the chromosome.
  * `rec_fractions`, the recombination factor associated to the marker.

In `genodata`, "2" stands for undetermined and is replaced by NA.

```{r}
bckg = names(cells)
genodata$chromosome = 1
genodata$position = 1:nrow(genodata)
genodata$prob_name = rownames(genodata)
genodata$rec_fractions = 0.05
genodata_ptl = preprocess_genodata(genodata, bckg)
```

#### Perform the ptl mapping using Kantovitch and multivariate moments method

The `plt_mapping` function scans genomes to detect PTLs using one of the two methods: `kanto` or `mmoments`. Refers to the publication for more details.
The common algorithm is the following:

Phenotypes of individuals are described by a vector (PCA on mm_matrix or MDS on kd_matrix).
The algorithm determines with the Kaiser criterion which dimensions of this orthogonal transformation are relevants for canonical analysis (`eig_to_scan`)
If `nb_dim=0`, a z-core criterion id used to determine how many dimensions the canonical analysis should use to give the best result. The main purpose is to fixe `nb_dim` in `2:max(eig_to_scan)`.
If `nb_dim=NULL`, `nb_dim` is automatically set to `max(eig_to_scan)`.
If `nb_dim>0` the canonical analysis is performed using the provided `nb_dim`. In this two last cases, keep in mind that a high value of `nb_dim` introduces a lot of degree of freedom in your canonical analysis. The number of dimension `nb_dim` needs to be __substantially__ smaller than the size of your population. 

```{r}
kanto_analysis = ptl_scan(kd_matrix, genodata_ptl, method="kanto")
mmoments_analysis = ptl_scan(mm_matrix, genodata_ptl, method="mmoments")
```

#### Perform the qtl mapping using the classic method

The `ptlmapper` package embed features of the famous `qtl` package [Broman et al. (2003)]. It allows to perform classic QTL mapping on univariate criteria (ex: mean, variance) using `ptlmapper` data structures. 

```{r}
rqtl_analysis = rqtl_launch(genodata_ptl, pheno_hists, kanto_analysis, mmoments_analysis)
```

### Workflow

All this steps are embeded in the `ptl_mapping` function. 
This function is a workflow that aggregates parameter values, inputs, and outputs of the call, to the R package `ptlmapper` function. 
The resulting data structure could be cache on the file system (using `ptl_mapping_filename` argument of the function). 
It is particularly useful to massivelly save multiple call to `plt_scan` and `rqtl_launch` function, for example in a complex distributed design adressing many single phenotypes on a given population. 

```{r, re
*** pas tres comprehensible *** 

```{r, results='hide'}
ptl_mapping_result = ptl_mapping(genodata, cells, bckg, nb_perm=20, bin_width=1)
```


### Result

These results concern univariate phenotype anal;ysis. This figures present genome scanned for mean, var and noise QTL mapping. 

#### QTL

```{r,fig.height=3, fig.width=9}
layout(matrix(1:3, 1, byrow=TRUE), respect=TRUE)
plot_rqtl(ptl_mapping_result, which_pheno=1)
plot_rqtl(ptl_mapping_result, which_pheno=2)
plot_rqtl(ptl_mapping_result, which_pheno=3)
```

#### PTL

These results concern multivariate approach with the two methods "kanto" and "mmoments".

##### Kantovitch method

The function `get_best_markers_rptl` returns the dtails of marker that obtains the best PTL score according to the `method` used.

```{r,fig.height=3, fig.width=9}
best_marker_kanto = get_best_markers_rptl(ptl_mapping_result, method="kanto")
print(best_marker_kanto)
```
The first figure presents individuals colored according their discriminant parental allele origin in the the two first dimensions of the multidimensional scaling space.
The second figure shows PTL mapping of the genome according using the "kanto" method.
On the third figures, details the result of the canonical discriminant analysis for the marker that obtains the best PTL score using the "kanto" method.


```{r,fig.height=3, fig.width=9}
layout(matrix(1:3, 1, byrow=TRUE), respect=TRUE)
best_marker_name = rownames(best_marker_kanto)[1]
col = marker2col(ptl_mapping_result, best_marker_name)
plot_orth_trans(ptl_mapping_result, col=col, method="kanto")
plot_wilks(ptl_mapping_result, method="kanto")
plot_can(ptl_mapping_result, best_marker_name, col=col, method="kanto")
```


##### multivariate moments method

```{r,fig.height=3, fig.width=9}
best_marker_mmoments = get_best_markers_rptl(ptl_mapping_result, method="mmoments")
print(best_marker_mmoments)
```
The first figure presents individuals colored according their discriminant parental allele origin on the two first components of the PCA.
The second figure shows PTL mapping of the genome according using the "mmoments" method.
On the third figures, details the result of the canonical discriminant analysis for the marker that obtains the best PTL score using the "mmoments" method.

```{r,fig.height=3, fig.width=9}
layout(matrix(1:3, 1, byrow=TRUE), respect=TRUE)
best_marker_name = rownames(best_marker_mmoments)[1]
col = marker2col(ptl_mapping_result, best_marker_name)
plot_orth_trans(ptl_mapping_result, col=col, method="mmoments")
plot_wilks(ptl_mapping_result, method="mmoments")
plot_can(ptl_mapping_result, best_marker_name, col=col, method="mmoments")
```




## Bibliography

  * Broman et al. (2003) R/qtl: QTL mapping in experimental crosses. Bioinformatics 19:889-890



## Acknowlegment

We are grateful to the Pole Scientifique de Modelisation Numerique (Lyon, France) and the Grid'5000 experimental testbed (www.grid5000.fr) for computer resource, and the Centre Blaise Pascal of ENS de Lyon for housing the code on a forge. This work was supported by the European Research Council under the European Union's Seventh Framework Programme FP7/2007-2013 [grant SiGHT number 281359].
